# -*- coding: utf-8 -*-################################################################################ Name: mpy.py                                                                ## Purpose:                                                                    ## Authors:                                                                    ##         Cody Precord <cprecord@editra.org>                                  ##         Mike Asker   <mike.asker@gmail.com>                                                      ## Copyright: (c) 2008 Cody Precord <staff@editra.org>                         ##                                                                             ## License: wxWindows License                                                  ##################################################################################  board_detection.py# #  This module detects the external board connection ##############################################################################"""Board Detection"""#-----------------------------------------------------------------------------## Importsimport osimport wximport sysimport subprocessimport shleximport timeimport reimport threadingimport find_launchpadimport find_stlinkimport serial_ = wx.GetTranslation#-----------------------------------------------------------------------------#class board_detection(object):    """Control window for showing and running scripts"""    def __init__(self, parent):               # MPY setup        self.python_exe   = r'%s\python.exe' % ( sys.exec_prefix )        tstr = sys.modules[__name__].__file__        idx = tstr.index(  r'\mpy_editor\mpy' )        self.mpy_dir = tstr[:idx]                        self.microDeviceStatus = 'Unknown'        self.microDebugLock = threading.Lock()        self.microDeviceSelected = 'Auto'        self.microDeviceDetected = 'Unknown'        self.microDevices = ['Auto', 'msp430g2211','msp430g2231','msp430g2452','msp430g2553' ]        self.microDevice = 'Unknown'        self.microConnectionStatus_previous = 'Not_Connected'        self.microConnectionStatus          = 'Not_Connected'        self.microComPort         = None        self.stlink_device        = None        self.openocd_popen         = None        self.previous_micro       = None        self.prog_in_progress = None                self.colors = { 'yellow'      : wx.Colour(255, 210,  95),                         'green'       : wx.Colour(174, 255, 111),                         'light_green' : wx.Colour(76,  239,  92),                        'red'         : wx.Colour(255, 133, 106),                         'grey'        : wx.Colour(128, 128, 128),  }        self.clr = { 'yellow'         : (255, 210,  95),                         'dark_green'       : (0x36, 0xa8, 0x41),                         'green' : (0x46, 0xdc,  0x55),                        'red'         : (255, 133, 106),                         'grey'        : (128, 128, 128),  }                                self.Locked = False        self.microStatusStr  =  '       Searching            '        self.microConnectionStatusColor   = wx.Colour(255, 210, 95)        # Start the Connection check loop. Once every 2 seconds it will look for the Microcontroller device        # and updated the connection status                self.con_check_thread = threading.Thread(target=self.CheckConnectionLoop, args=())        self.con_check_thread.start()        # Start the MPY uart serial COM-PORT interface. Enters a fast loop (0.05s)         # When the Connection status shows the Microcontroller present, it will open the port        # and wait for a line of data from the micro, and output it to the mpy window                self.uart_thread = threading.Thread(target=self.UartLoop, args=())        self.uart_thread.start()        # Connection Status of Microcontroller          self._conStatus = wx.StaticText(ctrlbar, wx.ID_ANY, self.microStatusStr, size=(120,15))        self._conStatus.SetForegroundColour(wx.Colour(0, 0, 0))        self._conStatus.SetBackgroundColour(self.microConnectionStatusColor)        ctrlbar.AddControl(self._conStatus, wx.ALIGN_LEFT)        self._conStatus.SetToolTipString(_("The Microcontroller Chip Connection Status,\nCOM port and microcontroller chip number"))        self._uartStopped = wx.CheckBox(ctrlbar, wx.ID_ANY, 'Stop UART')        self._uartStopped.SetToolTipString(_("Stops the UART messages from appearing on the mpyEditor console"))               ctrlbar.AddControl(self._uartStopped, wx.ALIGN_LEFT)            #-------------------------------------------------------------------------------------    def OnTimerCheckConnection(self, evt=None):        """Handle the Timer event for checking the connection status        @param evt: wx.CommandEvent                """         # Check to see if the micro board is connected or not        micro  = is_microcontroller_connected(self, self.previous_micro)        self.microComPort               = micro.comport_name        self.stlink_device              = micro.stlink_device        self.microConnectionStatus      = micro.microConnectionStatus        self.microConnectionStatusColor = micro.microConnectionStatusColor        self.openocd_popen               = micro.openocd_popen        self.previous_micro             = micro#         if 0 and self.uartStopped != True:#              wx.CallAfter( self.print_outbuf, ('                    --->>>  comport=%s  LPstatus=%s  StatColor=%s\n' % (self.microComPort, self.microConnectionStatus,self.microConnectionStatusColor )))        # If the connection status changed from not connected to connected,        # then do a full check to find out which microcontroller is on the board.        # Be aware that this will reset the microcontroller, so we only do a         # full check when the micro connection status changes        if (self.microConnectionStatus == 'Connected' and ( self.microConnectionStatus_previous != 'Connected') or \          self.microDeviceStatus == '_Microcontroller_Not_Found') or \          self.microDeviceStatus == '_No_Microcontroller_':            if self.microComPort != None:                self.microDeviceDetected, self.microDeviceStatus, self.microDeviceStatusColor = run_mspdebug_full(self)            if self.stlink_device != None:                self.microDeviceDetected =   self.stlink_device                self.microDeviceStatus   =   self.stlink_device                self.microDeviceStatusColor = 'green'                                            tstr = re.sub( '_', ' ', self.microDeviceDetected.upper() )            if self.stlink_device == None:                tstr = '%s: %s' % (self.microComPort, tstr)            else:                tstr = 'STLNK: %s' % (self.stlink_device)            self.microStatusStr = tstr            self.microStatusColor = self.colors[self.microDeviceStatusColor]            # It may be connected, but mspdebug may not have recognised that it is connected yet            # if so then force the connection status to not connected, so that it will try again            if self.microDeviceStatus == '_No_Microcontroller_':                #self.microConnectionStatus = 'Not_Connected'                pass        elif self.microConnectionStatus == 'Not_Connected':   # not connected            tstr = re.sub( '_', ' ', self.microConnectionStatus )            self.microStatusStr = tstr            self.microStatusColor = self.colors[self.microConnectionStatusColor]               else:  # still connected, don't update the connection status            pass                    self.microConnectionStatus_previous = self.microConnectionStatus        #        self.timer_con_status.Start(2000, oneShot=True)        return  (self.microStatusStr, self.microStatusColor )    #--------------------------------------------------------------------------------    def CheckConnectionLoop( self ):        '''Continuously running loop is run in a separate thread and is responsible for        checcking the connection status to the Microcontroller'''                try:            while 1:                    time.sleep(2)                (tstr, color) = self.OnTimerCheckConnection()                wx.CallAfter( self.UpdateConnectionStatus, (tstr,color) )        except wx.PyDeadObjectError: #                print 'CLOSING DOWN EXCEPTION CheckConnectionLoop PyDeadObjectError'             pass    #--------------------------------------------------------------------------------    def UpdateConnectionStatus( self, status):        '''Updates the GUI connection status, from the wx.CallAfter call from the          CheckConnectionLoop funcion which is running in a separate thread        '''                (tstr, color) = status        try:                self._conStatus.SetLabel( tstr )            self._conStatus.SetBackgroundColour(color)                except wx.PyDeadObjectError: #                print 'CLOSING DOWN EXCEPTION UpdateConnectionStatus PyDeadObjectError'            pass    #--------------------------------------------------------------------------------    def print_outbuf(self,txt):        '''print text to output buffer, using AppendUpdate'''                try:          self._buffer.AppendUpdate( txt  )          self._buffer.FlushBuffer()        except wx.PyDeadObjectError: #          print 'CLOSING DOWN EXCEPTION print_outbuf PyDeadObjectError'           pass    #--------------------------------------------------------------------------------    def print_outbuf_from_uart(self,txt):        '''print text to output buffer, using AppendUpdate        alternate version that is color coded to indicate txt is from different source ie the uart        '''                try:            cpos = self._buffer.GetLength()            self._buffer.AppendUpdate( txt  )            self._buffer.FlushBuffer()                        self._buffer.SetReadOnly(False)            self._buffer.StartStyling(cpos, 0x1f)            self._buffer.SetStyling(self._buffer.GetLength() - cpos, self._buffer.OPB_STYLE_UART)            self._buffer.SetReadOnly(True)                                except wx.PyDeadObjectError: #          print 'CLOSING DOWN EXCEPTION print_outbuf PyDeadObjectError'           pass             #--------------------------------------------------------------------------------    def prog_in_progress_loop(self):        '''Loop to flash the PROGRAM button while the program is being flashed'''        while self.prog_in_progress:            wx.CallAfter( self.set_GradientButton_color,  self._run, self.clr['red'] )            time.sleep(0.1)            wx.CallAfter( self.set_GradientButton_color, self._run, self.clr['green'] )            time.sleep(0.1)                #--------------------------------------------------------------------------------    def UartLoop(self):        '''This function prints out the UART comport data onto the mpy console, it is run in a separate thread.        So as not to slow down responsiveness of the main gui.                 1) If connection status is 'connected' and currently is not connected, then open the comport        2) If connection status is 'not connected' and currently is connected, then close the comport        3) If connected read a line from the uart port and output the line to the output window.        '''        time.sleep(3)  # Wait before starting up the loop to give time for other processes to start        port_open = False        self.serial_port = None        openned_comport = None               try:                    wx.CallAfter( self.print_outbuf, ('>>> [UartLoop] Started\n') )                     while(1):                                        time.sleep(0.05)  # wait 1/20 sec before looking again (frees up the cpu)                if 0 and self.uartStopped != True:                     wx.CallAfter( self.print_outbuf, ('>>>                     [UartLoop] running  %s\n'  % self.microConnectionStatus) )                if self.serial_port == None and self.microConnectionStatus == 'Connected' and self.microComPort != None:                                        try:                        self.serial_port = serial.Serial( self.microComPort, 9600, timeout=1 )                           port_open = True                        wx.CallAfter( self.print_outbuf, ('[openned comport %s]\n' % self.microComPort) )                        self.microConnectionStatus = 'Connected'                        openned_comport = self.microComPort                    except:                        #wx.CallAfter( self.print_outbuf, ('[*** error openning comport *** : %s]\n' % self.microComPort) )                        pass                                if port_open == True and self.microConnectionStatus != 'Connected':                     if self.serial_port != None:                        self.serial_port.close()                        wx.CallAfter( self.print_outbuf, ('[closed comport : %s]\n' % \                          (openned_comport)))                        self.serial_port = None                                    else:                        wx.CallAfter( self.print_outbuf, ('[warning: closed comport (comport was not open): %s]\n' % openned_comport) )                    port_open = False                if self.serial_port:                    line = self.serial_port.readline()                                            if self.prog_in_progress == None and line != '' and self.uartStopped != True :                         wx.CallAfter( self.print_outbuf_from_uart, (line) )                                                        except wx.PyDeadObjectError: #                print 'CLOSING DOWN EXCEPTION UartLoop PyDeadObjectError'            pass                     #--------------------------------------------------------def runcmd( command_line, log=False ):        args = shlex.split(command_line)        if log:   print 'command_line=', args                # options to prevent console window from openning        startupinfo = subprocess.STARTUPINFO()        startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW        startupinfo.wShowWindow = subprocess.SW_HIDE        p = subprocess.Popen( args , stdout=subprocess.PIPE,stderr=subprocess.STDOUT, startupinfo=startupinfo)        output = p.communicate()[0]         # remove any double linefeeds        output = re.sub('\r', '', output)        if log:   print 'x=', output        return output#------------------------------------------------------------------------def is_microcontroller_connected(parent, previous_micro=None):        '''This function runs mspdebug to determine whether the Microcontroller is connected        It does not cause the micro microcontroller chip to reset        @param  previous_micro  previous micro object, we need to reuse the data                                 if we have an already running openocd session        '''                        micro = find_launchpad.find_launchpad(parent)        micro.stlink_device   = None        micro.openocd_popen    = None        if micro.comport_name == None:                        micro = find_stlink.find_stlink(parent,                  config_pattern=r'stm*discovery.cfg',                  config_file_guess='stm32ldiscovery.cfg',                  openocd_exe=r'C:\openocd-0.7.0\openocd-0.7.0\bin-x64\openocd-x64-0.7.0.exe',                  previous_micro=previous_micro)            micro.comport_name = None                        if micro.comport_name != None or micro.stlink_device != None :            connection_status = 'Connected'  # green            color = 'yellow'        else:             connection_status = 'Not_Connected'  # red            color = 'red'                        if connection_status[0] == '_':            chip_id = connection_status #        parent._log("\n %s \n" % connection_status)          micro.microConnectionStatus          = connection_status        micro.microConnectionStatusColor     = color            return micro                #------------------------------------------------------------------------def run_mspdebug_full(parent):        '''This function will run mspdebug and find the chip number of the launchpad.        Running this function will cause the microcontroller to reset.'''#        parent.microDebugLock.acquire()        chip_id_dict = { '0xf201': 'msp430g2231',                          '0x2553': 'msp430g2553',                         '0x2452': 'msp430g2452',                         '0x0035': 'msp430g2231',                         '0x0036': 'msp430g2211',                         '0x00cf': 'msp430g2452',                         '0x00ab': 'msp430fr5739',                         '0x00de': 'msp430g2553',                       }        chip_id = 'Un-recognized'        mspdebug_ver = r'mspdebug'        print '(mspdebug started)...',        install_dir = r'%s\%s' % (parent.mpy_dir, mspdebug_ver)        cmd = r'%s\mspdebug.exe' % install_dir        cmd_opts = r'tilib "exit"'         command_line = '"%s" %s' % (cmd,cmd_opts)        op = runcmd( command_line )        if not re.search('\nDevice: .* \(id =',op):            print '*** ERROR *** Check Microcontroller is connected with MSP430 chip, or check driver installation'            connection_status = '_No_Microcontroller_'  # red            color = 'red'        else:            print '(mspdebug passed)   ' ,             wds =  re.findall(r'Device: .* \(id = (\S+)\)', op)    # Device: MSP430G2xx2 (id = 0x00cf)            device_id = wds[-1]            if device_id in chip_id_dict:                  chip_id = chip_id_dict[ device_id ]                print  ' found chip ', chip_id                 connection_status = 'Chip_Recognized'  # green                color = 'green'            else:                chip_id = device_id                print  ' Device ID:', device_id, chip_id                 connection_status =  device_id # yellow                color = 'yellow'                if connection_status[0] == '_':            chip_id = connection_status #        parent.microDebugLock.release()        util.Log("[mpy](run_mspdebug_full)  ----------------------------   %s %s %s" % (chip_id, connection_status, color))        return chip_id, connection_status, color    